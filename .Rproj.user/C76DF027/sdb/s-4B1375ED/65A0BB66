{
    "collab_server" : "",
    "contents" : "OptimalPortfolio <- function(Expt_Ret_Matr, covar_matrix, short) {\n  #We use matrix calculus to solve the optimization pb\n  Expt_Ret <- Expt_Ret_Matr\n  cov_matr <- covar_matrix\n  if(short == \"yes\"){\n    inv_cov_matr <- solve(cov_matr)\n    one_vec <- rep(1, nrow(cov_matr))\n    top_mat <- inv_cov_matr %*% Expt_Ret\n    bot_val <- as.numeric(t(one_vec) %*% top_mat)\n    opt_weights <- top_mat[, 1] / bot_val\n  }else{\n    D_mat <- 2*cov_matr\n    d_vec <- rep(0, nrow(cov_matr))\n    A_mat <- cbind(Expt_Ret, diag(1, nrow(cov_matr)))\n    b_vec <- c(1, rep(0, nrow(cov_matr)))\n    opt_weights <- solve.QP(D_mat, d_vec, A_mat, b_vec, meq=1)\n    opt_weights <- opt_weights$solution/sum(opt_weights$solution)\n  }\n  opt_Ret <- as.numeric(crossprod(opt_weights, Expt_Ret))\n  opt_Risk <- sqrt(as.numeric(t(opt_weights) %*% cov_matr %*% opt_weights))\n  Results <- list(opt_weights, opt_Ret, opt_Risk)\n  return(Results)\n}\n\ngetRawData <- function(url){\n  mydata <- read.csv(url, header = FALSE, sep = \",\", fill = TRUE, stringsAsFactors = FALSE)\n  return (mydata)\n}\n\ngetData <- function(rawData) {\n  \n  split_ref <- c()\n  result <- list()\n  for (i in 1:nrow(rawData)){\n    if (rawData[i, 1] == \"DATE\"){\n      split_ref <- append(split_ref, i-1)\n    }\n  }\n  result <- split(rawData, findInterval(1:nrow(rawData), split_ref))\n  \n  for (i in 1 : length(result)){\n    result[[i]] <- result[[i]][3 : nrow(result[[i]]), ]\n  }\n  return(result) \n}\n\ngetMonthlyReturns <- function(list) {\n  returns <- list()\n  for(i in 1 : length(list)){\n    stock_returns <- list()\n    #we calculate the monthly arithmetic return of the stock, index 1 = more redent month\n    for(j in 2 : nrow(list[[i]])){\n      stock_returns[[j-1]]<- (as.numeric(list[[i]][j - 1, 5]) - as.numeric(list[[i]][j, 5])) / as.numeric((list[[i]][j, 5]))\n    }\n    returns[[i]] <- stock_returns\n  }\n  return(returns)\n}\n\ngetYearlyReturns <- function(list) {\n  returns <- list()\n  for(i in 1 : length(list)){\n    stock_returns <- list()\n    if (nrow(list[[i]]) <= 12){\n      stock_returns <- append(stock_returns, (as.numeric(list[[i]][1, 5]) - as.numeric(list[[i]][nrow(list[[i]]), 5])) / as.numeric(list[[i]][nrow(list[[i]]), 5]))\n    }\n    #we calculate the yearly arithmetic return of the stock, index 1 = more redent month\n    for(j in seq(1, nrow(list[[i]])-12, 12)){\n      stock_returns <- append(stock_returns, (as.numeric(list[[i]][j, 5]) - as.numeric(list[[i]][j + 12, 5])) / as.numeric(list[[i]][j + 12, 5]))\n    }\n    returns[[i]] <- stock_returns\n  }\n  return(returns)\n}\n\ngetCovMatr <- function(list) {\n  sizes <- c()\n  covar <- c()\n  for (i in 1 : length(list)){\n    sizes[i] <- length(list[[i]])\n  }\n  for(j in 1 : length(list)){\n    for (l in 1 : length(list)){\n      stock_vector <- c()\n      #we calculate the monthly value of the covariance, then we sum all these values and create the covariance matrix\n      for(k in 1 : min(sizes)){\n        stock_vector[[k]]<- 12 * (list[[j]][[k]] - aver(list[[j]])) * (list[[l]][[k]] - aver(list[[l]])) / (min(sizes) - 1)\n      }\n      covar <- append(covar, Reduce(\"+\", stock_vector))\n    }\n  }\n  covar_mat <- matrix(covar, nrow = length(list), ncol=length(list))\n  return(covar_mat)\n}\n\naver <- function(list) {\n  #we calculate the average of the elements of list\n  av <- Reduce(\"+\", list) / length(list)\n  return(av)\n}\n\ngetMinVarPort <- function(Expt_Ret, covar_matrix, short) {\n  #we use matrix calculus to solve the minimization problem with the constraint that the sum of all assets' weight is equal to 1 (or 100%)\n  if(short ==  \"yes\"){\n    top_matrix <- cbind(2*covar_matrix, rep(1, nrow(covar_matrix)))\n    vect <- c(rep(1, nrow(covar_matrix)), 0)\n    mat <- rbind(top_matrix, vect)\n    res_vector <- c(rep(0, nrow(covar_matrix)), 1)\n    final_mat <- solve(mat) %*% res_vector\n    Min_weights <- final_mat[1 : nrow(covar_matrix), 1]\n  }else{\n    D_mat <- 2*covar_matrix\n    d_vec <- rep(0, nrow(covar_matrix))\n    A_mat <- cbind(rep(1, nrow(covar_matrix)), diag(1, nrow(covar_matrix)))\n    b_vec <- c(1, rep(0, nrow(covar_matrix)))\n    Min_weights <- solve.QP(D_mat, d_vec, A_mat, b_vec, meq=1)\n    Min_weights <- Min_weights$solution\n  }\n  Min_Exp <- as.numeric(crossprod(Min_weights, Expt_Ret))\n  Min_Risk <- sqrt(as.numeric(t(Min_weights) %*% covar_matrix %*% Min_weights))\n  Results <- list(Min_weights, Min_Exp, Min_Risk)\n  return(Results)\n}\n\ngetEfficientPort <- function(Exp_Ret, cov_matrix, short, min_Exp_Ret) {\n  #we use matrix calculus to solve the problem\n  if (short == \"yes\"){\n    top_matrix <- cbind(2*cov_matrix, Exp_Ret, rep(1, nrow(cov_matrix)))\n    mid_matrix <- c(Exp_Ret, 0, 0)\n    bot_matrix <- c(rep(1, nrow(cov_matrix)), 0, 0)\n    final_matrix <- rbind(top_matrix, mid_matrix, bot_matrix)\n    vector <- c(rep(0, nrow(cov_matrix)), max(Exp_Ret), 1)\n    prod <- solve(final_matrix) %*% vector\n    Eff_Weights <- prod[1 : nrow(cov_matrix), ]\n    Eff_Expt <- as.numeric(crossprod(Eff_Weights, Exp_Ret))\n    Eff_Risk <- sqrt(as.numeric(t(Eff_Weights) %*% cov_matrix %*% Eff_Weights))\n    Result <- list(Eff_Weights, Eff_Expt, Eff_Risk)\n  }else{\n    Eff_Weights <- list()\n    i <- 1\n    for(target in seq(min_Exp_Ret, max(Exp_Ret), 0.005)){\n      D_mat <- 2*cov_matrix\n      d_vec <- rep(0, nrow(cov_matrix))\n      A_mat <- cbind(rep(1, nrow(cov_matrix)), Exp_Ret, diag(1, nrow(cov_matrix)))\n      b_vec <- c(1, target, rep(0, nrow(cov_matrix)))\n      weights_list <- solve.QP(D_mat, d_vec, A_mat, b_vec, meq=2)\n      tryCatch({\n        weights_list$solution\n      }, error = function(x){\n        next\n      })\n      Eff_Weights[[i]] <- weights_list$solution\n      i <- i + 1\n    }\n    Result <- list(Eff_Weights, NULL, NULL)\n  }\n  return(Result)\n}\n\ngetEffFrontier <- function(Min_Weights, Effi_weights, Exp_Ret, cov_matrix, short, Min_Exp) {\n  #according to the two fund separation theorem every protfolio on the efficient frontier is a combination of two portfolios from the efficient frontier\n  Exp <- c()\n  Risk <- c()\n  if(short == \"yes\"){\n    a <- seq(-1.5, 2.5, 0.01)\n    #we compute a list of efficient portfolios composed with the minimum portfolio and the efficient portfolio\n    for(i in a){\n      z <- i * Min_Weights + (1 - i) * Effi_weights\n      E <- as.numeric(crossprod(z, Exp_Ret))\n      if (E >= Min_Exp){\n        Exp <- append(Exp, E)\n        R <- sqrt(as.numeric(t(z) %*% cov_matrix %*% z))\n        Risk <- append(Risk, R)\n      }\n    }\n  }else{\n    for (i in 1:length(Effi_weights)){\n      E <- as.numeric(crossprod(Effi_weights[[i]], Exp_Ret))\n      Exp <- append(Exp, E)\n      R <- sqrt(as.numeric(t(Effi_weights[[i]]) %*% cov_matrix %*% Effi_weights[[i]]))\n      Risk <- append(Risk, R)\n    }\n  }\n\n  results <-list(Exp, Risk)\n  return(results)\n}\n\ngetCapitalAssetLine<- function(opt_Ret, Rf,opt_Risk) {\n  #we calculate the CAL's equation using two points : the optimal portfolio and the risk free rate\n  a <- (opt_Ret-Rf) / (opt_Risk)\n  b <- Rf\n  x <- seq(0, 1, 0.01)\n  y <- a * x + b\n  results <- list(x, y)\n  return(results)\n}\n\ngetCompletePortfolio <- function(propor, Rf, opt_Exp, opt_Risk, opt_weights, Expt_Ret, cov_matix) {\n  comp_weights <- (1 - propor) * opt_weights\n  Exp_Ret <- propor * Rf + (1 - propor) * opt_Exp\n  Risk <- (1 - propor) * opt_Risk\n  results <- list(comp_weights, Exp_Ret, Risk)\n  return(results)\n}\n\ngetHistoricalReturn <- function(list) {\n  results <- c()\n  for(i in 1 : length(list)){\n    results[i]<- mean(as.numeric(list[[i]]))\n  }\n  return(results)\n}\n\ncreateURL <- function(stock_names, start_year, start_month, start_day, start_hour, start_min, start_sec, start_ms, start_zone, end_year, end_month, end_day, end_hour, end_min, end_sec, end_ms, end_zone){\n  url_yahoo <- paste0(\"http://adage.cse.unsw.edu.au:8080/yahooAPI/v1/data?a_year=\", start_year,\"&a_mon=\", start_month, \"&a_day=\", start_day, \"&a_hour=\", start_hour, \"&a_min=\", start_min, \"&a_sec=\", start_sec, \"&a_ms=\", start_ms, \"&a_zone=\", start_zone, \"&z_year=\", end_year,\"&z_mon=\", end_month, \"&z_day=\", end_day, \"&z_hour=\", end_hour, \"&z_min=\", end_min, \"&z_sec=\", end_sec, \"&z_ms=\", end_ms, \"&z_zone=\", end_zone, \"&period=m\")\n  for (i in 1 : length(stock_names)){\n    url_yahoo <- paste0(url_yahoo, \"&ins_code=\", stock_names[i])\n  }\n  return(url_yahoo)\n}\n\ngetActualRange <- function(mydata){\n  range <- list()\n  for (i in 1 : length(mydata)){\n    if (i == 1){\n      size_set <- nrow(mydata[[i]])\n    } else if (nrow(mydata[[i]]) < size_set){\n      size_set <- nrow(mydata[[i]])\n    }\n    range[[1]] <- mydata[[i]][nrow(mydata[[i]]), 1]\n    range[[2]] <- mydata[[i]][1, 1]\n    \n  }\n  return (range)\n}\n\n",
    "created" : 1465124175399.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3042211002",
    "id" : "65A0BB66",
    "lastKnownWriteTime" : 1464665812,
    "last_content_update" : 1464665812,
    "path" : "~/R/portfolio/portfolioTool/Optimal_Portfolio.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}